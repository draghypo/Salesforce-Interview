Queueable: - It is an Apex interface used to run jobs asynchronously in the background. It lets you process records outside
              the main transaction and supports passing complex data, chaining jobs, and tracking their status.

  Syntax:- public class MyQueueableClass implements Queueable {

                // Constructor to pass data to the class (optional)
                public MyQueueableClass(List<Account> accountsToProcess) {
                    // Store the data for the execute method
                }

                // The execute method contains the logic to run asynchronously
                public void execute(QueueableContext context) {
                    // Your logic to process the data (e.g., update records)
                    for (Account acc : accountsToProcess) {
                        acc.Name = acc.Name + ' - Processed';
                    }
                    update accountsToProcess;
                }
            }
      calling process of queueable class:- 
                                        // Prepare data (query some accounts)
                                        List<Account> accList = [SELECT Id, Name FROM Account LIMIT 5];
                                        // Enqueue the job
                                        System.enqueueJob(new MyQueueableClass(accList));


      Why we use queueable apex: - 
                              => Async processing: Run logic that takes too long for a normal transaction.
                                
                              => Chaining jobs: Unlike Future methods, you can chain Queueables, meaning one job can enqueue another.
                                
                              => Complex objects: Can pass SObjects and complex types (Future methods can only pass primitives).
                                
                              => Error handling: Works with Finalizer interface to handle cleanup or retries.

    How Queueable Apex work: - 
                                You implement the Queueable interface.
                                Override the execute(QueueableContext qc) method.
                                Submit the job using System.enqueueJob(new MyQueueable()).
                                Salesforce executes it asynchronously when resources are available.
                                Optionally, implement Finalizer to run cleanup logic after the job finishes, even if it fails.
  
  Key Advantages Over Future Methods: - 
                   ----------------------------------------------------------------------------------------|
                   | Feature          |    	Queueable	                               |  Future Method      |
                   |---------------------------------------------------------------------------------------|
                   | Parameter types  |  	  Complex objects, SObjects, collections	 |  Only primitives    | 
                   | Chaining	        |      Yes                                     |       	No           |
                   | Monitoring	      |      Job appears in Setup → Apex Jobs	       |        No           |
                   | Error            |       handling	Can use Finalizer	           |        No           |
                   -----------------------------------------------------------------------------------------
*********************************************************************************************************************************************************
  Scenario: Update Related Contacts When Account Field Changes.
  Business Requirement: Whenever an Account’s Industry changes, all related Contacts’ Department field should be updated to match the Account’s Industry.

      Solution Analysis: -  Doing this synchronously can hit governor limits if there are thousands of Contacts.
                            Queueable Apex can handle this asynchronously and efficiently.
                            Future method not best for it, reason is: - a).Future methods cannot accept SObjects (like List<Account>).
                                                                                  You would have to pass primitive types only (e.g., List of IDs), then query the Accounts again inside the future method.
                                                                                  Extra SOQL queries → more governor limits risk.
                                                                        b). Monitoring and job control : - Queueable returns a Job Id when enqueued → easier to track, abort, or log failures.
                                                                        c). Complex business logic: - It has has multiple steps (Accounts → Related Contacts → Update) → Queueable supports bulk-safe patterns and constructor parameters.
                                                                                                      Future methods would require re-querying data, more coding, and less maintainability.
                            Batch class also not suitable for it, reaon is : - calling batchclass from trigger is not a best practice, because Batch has 3 phase start(), execute() and finish() so it is used for large dataset.
                                                                                a).Queueable runs in a single async execution, much lighter.
                                                                                b). We don’t use Batch here because the volume is not very large; Batch is designed for millions of records and adds unnecessary overhead. Queueable is lighter, faster, and better suited for medium-sized async tasks like updating related Contacts when an Account changes.

          so finally go with the queueable class: - 
                             Trigger:- 
                                              trigger AccountTriggerTest on Account (after update) {
                                                  List<Id> changedAccounts = new List<Id>();
                                                  for (Account acc : Trigger.new) {
                                                      Account oldAcc = Trigger.oldMap.get(acc.Id);
                                                      if (acc.Industry != oldAcc.Industry) {
                                                          changedAccounts.add(acc.Id);
                                                      }
                                                  }
                                                  if (!changedAccounts.isEmpty()) {
                                                      for (Id accId : changedAccounts) {
                                                          System.enqueueJob(new UpdateContactsWithFinalizer(accId));
                                                      }
                                                  }
                                              }
                            Queueable class: - 
                                          public class UpdateContactsWithFinalizer implements Queueable, Finalizer {
                                          
                                              private Id accountId;
                                          
                                              // Constructor to pass Account Id from trigger
                                              public UpdateContactsWithFinalizer(Id accId) {
                                                  this.accountId = accId;
                                              }
                                          
                                              // Queueable execution
                                              public void execute(QueueableContext qc) {
                                                  List<Contact> contactsToUpdate = new List<Contact>();
                                          
                                                  // Query Account Industry
                                                  Account acc = [SELECT Id, Industry FROM Account WHERE Id = :accountId LIMIT 1];
                                          
                                                  // Query related Contacts
                                                  for (Contact con : [SELECT Id, Department FROM Contact WHERE AccountId = :accountId]) {
                                                      con.Department = acc.Industry;
                                                      contactsToUpdate.add(con);
                                                  }
                                          
                                                  if (!contactsToUpdate.isEmpty()) {
                                                      update contactsToUpdate;
                                                  }
                                              }
                                          
                                              // Finalizer method - runs always (success or failure)
                                              public void execute(FinalizerContext fc) {
                                                  AsyncApexJob job = [SELECT Id, Status, NumberOfErrors, ExtendedStatus 
                                                                      FROM AsyncApexJob WHERE Id = :fc.getAsyncApexJobId()];
                                          
                                                  Messaging.SingleEmailMessage mail = new Messaging.SingleEmailMessage();
                                                  mail.setToAddresses(new String[] { 'sadiquex.alam@intel.com' }); // Change recipient
                                                  mail.setSubject('Queueable Job Result: Update Contacts');
                                                  
                                                  if (job.Status == 'Completed') {
                                                      mail.setPlainTextBody('The Contacts related to Account ' + accountId + 
                                                                            ' were updated successfully.');
                                                  } else {
                                                      mail.setPlainTextBody('The Queueable job failed for Account ' + accountId + 
                                                                            '. Error: ' + job.ExtendedStatus);
                                                  }
                                          
                                                  Messaging.sendEmail(new Messaging.SingleEmailMessage[] { mail });
                                              }
                                          }
             
        Note:- Finalizer Interface: - Finalizer is a System interface implemented in a Queueable class to execute logic after the job finishes, regardless of success or failure like finally block in java.
            Syntax: - public void execute(FinalizerContext fc) {
                        System.debug('It acts like a finally block in Java');
                     }
            
           FinalizerContext has four methods: - 
                                                  a).Id getAsyncApexJobId:- it will provide the job id of the current queable.
                                                                  Id jobId = fc.getAsyncApexJobId();
                                                                  System.debug('Job Id: ' + jobId);

                                                  b). FinalizerResult getResult() :- What it does: Returns the final outcome of the Queueable job.
                                                                              FinalizerResult.SUCCESS → job completed successfully
                                                                              FinalizerResult.UNHANDLED_EXCEPTION → job failed due to unhandled exception
                                                                              FinalizerResult.ABORTED → job was aborted
                                                                      syntax: -  if(fc.getResult() == FinalizerResult.SUCCESS){
                                                                                      System.debug('Job completed successfully!');
                                                                                  }
                                                  c). Exception getException() :- Returns the exception object if the Queueable failed.
                                                                      syntax: - if(fc.getResult() == FinalizerResult.UNHANDLED_EXCEPTION){
                                                                                    System.debug('Exception: ' + fc.getException());
                                                                                }


                                                                                                                                        
                                                                                        
                                                                                                                                      
                      global void attachFinalizer(Finalizer finalizer) {} :- attachFinalizer() lets you dynamically attach a Finalizer to a Queueable job so that post-processing logic runs after the job finishes, regardless of success or failure.
                                finalize class:- 
                                                  public class MyFinalizer implements Finalizer {
                                                      public void execute(FinalizerContext fc) {
                                                          System.debug('Finalizer executed after Queueable finishes');
                                                          System.debug('Job Id: ' + fc.getAsyncApexJobId());
                                                          System.debug('Job Result: ' + fc.getResult());
                                                      }
                                                  }
                                Queueable class: - 
                                                  public class MyQueueable implements Queueable {
                                                      public void execute(QueueableContext qc) {
                                                          System.debug('Queueable is running');
                                                  
                                                          // Attach a separate Finalizer dynamically
                                                          qc.attachFinalizer(new MyFinalizer());
                                                      }
                                                  }
                                Job start:- System.enqueueJob(new MyQueueable());


